# The script retrieves information from the Cyberwatch API to generate a CSV reports for each function :
# outdated operating systems, top 10 impactful CVEs, patched CVEs, discovered CVEs, and top 10 impactful KBs.

from cyberwatch_api import Cyberwatch_Pyhelper
import datetime
import warnings
import csv
from collections import defaultdict
import operator

# Disable SSL warnings
warnings.filterwarnings("ignore", message="Unverified HTTPS request")

# Initialize Cyberwatch_Pyhelper
cyberwatch = Cyberwatch_Pyhelper()

# Function to retrieve the list of unique assets
def get_all_assets():
    all_assets = []
    seen_hostnames = set()
    page = 1
    per_page = 500

    while True:  # Infinite loop until no more assets are available
        print(f"[DEBUG] Fetching page {page} of assets...")
        output = cyberwatch.request(
            method="get",
            endpoint="/api/v3/servers",
            body_params={"page": page, "per_page": per_page},
            verify_ssl=False
        )

        assets = next(output).json()  # Retrieve the first line from the generator
        if not assets:
            print("[DEBUG] No further data found, stopping fetch job.")
            break

        # Add unique assets
        new_assets = [asset for asset in assets if asset["hostname"] not in seen_hostnames]
        all_assets.extend(new_assets)
        seen_hostnames.update(asset["hostname"] for asset in new_assets)

        print(f"[DEBUG] Page {page} fetched successfully, {len(new_assets)} unique assets added.")

        # Check if the number of assets returned is less than `per_page`
        if len(assets) < per_page:
            print("[DEBUG] Fewer assets than expected, reached the last page.")
            break

        page += 1

    print(f"[DEBUG] Total unique assets retrieved: {len(all_assets)}")
    return all_assets

# Function to get outdated operating systems
def get_obsolete_os():
    print("[DEBUG] Starting retrieval of outdated operating systems.")
    servers = get_all_assets()
    obsolete_os = []
    for server in servers:
        if server.get("os") and server["os"].get("eol") and server["os"]["eol"] < str(datetime.date.today()):
            obsolete_os.append({"os": server["os"]["name"], "assets": server["hostname"]})
    print("[DEBUG] Retrieval of outdated operating systems completed.")
    return obsolete_os

# Function to get the top 10 CVEs affecting the most assets
def get_top_10_cve():
    print("[DEBUG] Starting calculation of the most impactful CVEs.")
    servers = get_all_assets()
    cve_count = {}

    for server in servers:
        output = cyberwatch.request(
            method="get",
            endpoint=f"/api/v3/vulnerabilities/servers/{server['id']}",
            verify_ssl=False
        )

        vulnerabilities = next(output).json().get("cve_announcements", [])
        for cve in vulnerabilities:
            cve_code = cve["cve_code"]
            cve_score = cve["score"]

            if cve_code not in cve_count:
                cve_count[cve_code] = {"asset_count": 0, "assets": set(), "score": cve_score}

            cve_count[cve_code]["asset_count"] += 1
            cve_count[cve_code]["assets"].add(server["hostname"])

    for cve in cve_count.values():
        cve["assets"] = list(cve["assets"])

    sorted_cve = sorted(cve_count.items(), key=lambda x: x[1]["asset_count"], reverse=True)[:10]
    sorted_cve = [(cve_code, data["asset_count"], data["score"], data["assets"]) for cve_code, data in sorted_cve]

    print("[DEBUG] CVE calculation completed.")
    return sorted_cve

# Function to get patched CVEs
def get_patched_cve():
    print("[DEBUG] Starting calculation of patched CVEs.")
    servers = get_all_assets()
    patched_cve = defaultdict(int)  # Dictionary to count patches by month

    for server in servers:
        output = cyberwatch.request(
            method="get",
            endpoint=f"/api/v3/vulnerabilities/servers/{server['id']}",
            verify_ssl=False
        )

        vulnerabilities = next(output).json().get("cve_announcements", [])
        for cve in vulnerabilities:
            cve_code = cve["cve_code"]
            fixed_at = cve.get("fixed_at")

            if fixed_at:
                try:
                    fixed_date = datetime.datetime.strptime(fixed_at, "%Y-%m-%dT%H:%M:%S.%f%z")
                    patched_cve[fixed_date.strftime("%m/%Y")] += 1  # Count patched CVEs by month
                except ValueError as e:
                    print(f"[ERROR] Invalid 'fixed_at' date format for CVE {cve_code}: {fixed_at}. Error: {e}")

    print("[DEBUG] Patched CVEs by month: ", patched_cve)
    return patched_cve

# Function to get new CVEs
def get_new_cve():
    print("[DEBUG] Starting retrieval of newly discovered CVEs.")
    servers = get_all_assets()
    new_cve = defaultdict(int)  # Dictionary to count discoveries by month

    for server in servers:
        output = cyberwatch.request(
            method="get",
            endpoint=f"/api/v3/vulnerabilities/servers/{server['id']}",
            verify_ssl=False
        )

        vulnerabilities = next(output).json().get("cve_announcements", [])
        for cve in vulnerabilities:
            cve_code = cve["cve_code"]
            detected_at = cve.get("detected_at")

            if detected_at:
                try:
                    detected_date = datetime.datetime.strptime(detected_at, "%Y-%m-%dT%H:%M:%S.%f%z")
                    new_cve[detected_date.strftime("%m/%Y")] += 1  # Count discovered CVEs by month
                except ValueError as e:
                    print(f"[ERROR] Invalid 'detected_at' date format for CVE {cve_code}: {detected_at}. Error: {e}")

    print("[DEBUG] Newly discovered CVEs by month: ", new_cve)
    return new_cve

# Function to get the top 10 KBs that fix the most CVEs
def get_top_10_kb_from_cve():
    print("[DEBUG] Calculating vulnerable KBs from patchable CVEs.")
    dict_kbs_asset = {}
    dict_kbs_cve = {}
    assets = get_all_assets()

    for asset in assets:
        output = cyberwatch.request(
            method="get",
            endpoint=f"/api/v3/vulnerabilities/servers/{asset['id']}",
            verify_ssl=False
        )

        cve_details = next(output).json()
        for cve in cve_details.get("updates", []):
            if cve.get("target") and cve["target"].get("type") == "Packages::Kb":
                kb = cve["target"].get("product")
                cves = len(cve.get("cve_announcements", []))
                dict_kbs_asset[kb] = dict_kbs_asset.get(kb, 0) + 1
                dict_kbs_cve[kb] = dict_kbs_cve.get(kb, 0) + cves

    sorted_kb = sorted(dict_kbs_asset.items(), key=operator.itemgetter(1), reverse=True)[:10]
    result = []
    for kb_id, actif_number in sorted_kb:
        result.append([kb_id, actif_number, dict_kbs_cve.get(kb_id, 0)])

    print("[DEBUG] KB calculation completed.")
    return result

# Function to generate the CSV report
def generate_csv_report():
    print("[DEBUG] Starting CSV report generation.")
    top_cve = get_top_10_cve()
    patched_cve = get_patched_cve()
    new_cve = get_new_cve()
    obsolete_os = get_obsolete_os()

    with open("top_10_cve.csv", mode="w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["CVE Code", "Number of Assets", "CVSS Score", "Affected Assets"])
        for cve_code, asset_count, score, assets in top_cve:
            writer.writerow([cve_code, asset_count, score, ", ".join(assets)])

    with open("patched_cve.csv", mode="w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["Month", "Number of Patched CVEs"])
        for month, count in sorted(patched_cve.items()):
            writer.writerow([month, count])

    with open("discovered_cve.csv", mode="w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["Month", "Number of Discovered CVEs"])
        for month, count in sorted(new_cve.items()):
            writer.writerow([month, count])

    with open("top_10_kb_report.csv", mode="w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["KB ID", "Number of Affected Assets", "CVEs"])
        kb_list = get_top_10_kb_from_cve()
        for elements in kb_list:
            writer.writerow([elements[0], str(elements[1]), str(elements[2])])

    with open("obsolete_os.csv", mode="w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["Outdated OS", "Affected Assets"])
        for item in obsolete_os:
            writer.writerow([item["os"], item["assets"]])

    print("[DEBUG] CSV report generation completed.")

# Start report generation
generate_csv_report()
